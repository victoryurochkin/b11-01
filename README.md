# Домашнее задание к занятию Домашнее задание к занятию «Базы данных, их типы» - Юрочкин В.А.

---

Задание 1. СУБД
Кейс
Крупная строительная компания, которая также занимается проектированием и девелопментом, решила создать правильную архитектуру для работы с данными. Ниже представлены задачи, которые необходимо решить для каждой предметной области.

Какие типы СУБД, на ваш взгляд, лучше всего подойдут для решения этих задач и почему?

1.1. Бюджетирование проектов с дальнейшим формированием финансовых аналитических отчётов и прогнозирования рисков. СУБД должна гарантировать целостность и чёткую структуру данных.

1.1.* Хеширование стало занимать длительно время, какое API можно использовать для ускорения работы?

1.2. Под каждый девелоперский проект создаётся отдельный лендинг, и все данные по лидам стекаются в CRM к маркетологам и менеджерам по продажам. Какой тип СУБД лучше использовать для лендингов и для CRM? СУБД должны быть гибкими и быстрыми.

1.2.* Можно ли эту задачу закрыть одной СУБД? И если да, то какой именно СУБД и какой реализацией?

1.3. Отдел контроля качества решил создать базу по корпоративным нормам и правилам, обучающему материалу и так далее, сформированную согласно структуре компании. СУБД должна иметь простую и понятную структуру.

1.3.* Можно ли под эту задачу использовать уже существующую СУБД из задач выше и если да, то как лучше это реализовать?

1.4. Департамент логистики нуждается в решении задач по быстрому формированию маршрутов доставки материалов по объектам и распределению курьеров по маршрутам с доставкой документов. СУБД должна уметь быстро работать со связями.

1.4.* Можно ли к этой СУБД подключить отдел закупок или для них лучше сформировать свою СУБД в связке с СУБД логистов?

1.5.* Можно ли все перечисленные выше задачи решить, используя одну СУБД? Если да, то какую именно?

Приведите ответ в свободной форме.


`Ответ:`

## 1.1. Бюджетирование проектов + финансовые отчёты + прогнозирование рисков  
Для этой задачи критична строгая структура данных, высокая надёжность и поддержка транзакций. Поэтому лучше всего подходит **реляционная СУБД (OLTP)** — например, PostgreSQL, Oracle или MS SQL Server.  
Они дают ACID-транзакции, чёткие схемы, контроль целостности и работают надёжно с денежными значениями.

Для аналитики (отчёты, своды, прогнозы) лучше использовать отдельное **аналитическое DWH** — например, ClickHouse или Greenplum, чтобы тяжёлые отчёты не тормозили основную базу.

### 1.1.* Хеширование стало медленным — что использовать?  
Для ускорения хеширования можно использовать готовые оптимизированные крипто-API, например:
- **OpenSSL EVP API**,  
- **libsodium**,  
- готовые реализации bcrypt/argon2.  
Также можно вынести тяжёлое хеширование в отдельный сервис и выполнять его параллельно.

---

## 1.2. Лендинги + CRM по лидам  
Для лендингов данные постоянно меняются, формы у лидов разные, и нужно быстро писать данные. Поэтому удобнее использовать **NoSQL (документные)** СУБД, например MongoDB — схема гибкая, можно хранить разные структуры данных без миграций.

Для CRM нужны связи: клиент → сделка → задачи → активности. Здесь лучше использовать **реляционную СУБД** (PostgreSQL/MySQL), потому что в ней удобнее работать с отношениями и отчётами.

### 1.2.* Можно ли всё закрыть одной СУБД?  
Да, можно использовать **PostgreSQL**:
- CRM хранить в нормальных таблицах,
- лиды хранить в таблице с колонкой `jsonb`, куда помещаются динамические поля формы.  

PostgreSQL хорошо сочетает SQL и JSONB, поэтому одна СУБД может закрыть обе задачи.

---

## 1.3. База корпоративных норм, правил и обучающих материалов  
Здесь нужна простая, понятная структура. Подойдёт обычная **реляционная СУБД** — например, PostgreSQL.  
Она позволяет сделать структурированные разделы, статьи, файлы, теги, и можно добавить полнотекстовый поиск.

### 1.3.* Можно ли использовать существующую СУБД?  
Да, можно.  
Например, если уже используется PostgreSQL — создать в ней отдельную **схему** `knowledge_base` и хранить материалы там. Это удобно администрировать и не требует новой инфраструктуры.

---

## 1.4. Логистика: маршруты доставки, курьеры, объекты  
Задача требует работать со связями и маршрутами.  
Тут хорошо подходят:
- **графовые СУБД** (Neo4j) — прямой инструмент для поиска маршрутов и связей.
- Или **PostgreSQL + PostGIS + pgRouting**, если хочется остаться в реляционной экосистеме.

### 1.4.* Подключить закупки к этой же СУБД?  
Да, можно.  
Закупки используют справочники материалов, поставщиков и складов, которые нужны и логистике.  
Обычно делают так:  
- общая реляционная БД со справочниками,  
- логистика использует либо эту же БД, либо отдельную графовую подсистему, но данные синхронизируются.

---

## 1.5.* Можно ли решить всё одной СУБД?  
Теоретически — да.  
Практически — тоже можно, если использовать **PostgreSQL как универсальный вариант**, потому что он:
- поддерживает классический SQL (OLTP),
- имеет JSONB для гибких структур,
- поддерживает полнотекстовый поиск для базы знаний,
- имеет расширения PostGIS и pgRouting для логистики.

Получается один мощный кластер PostgreSQL, в котором:
- разные задачи разделены по схемам,
- каждая область использует свой набор таблиц,
- а расширения закрывают все специфические потребности.

Но важно правильно настроить ресурсы, индексы и разделить нагрузки, чтобы одна задача не мешала другой.

---
Задание 2. Транзакции
2.1. Пользователь пополняет баланс счёта телефона, распишите пошагово, какие действия должны произойти для того, чтобы транзакция завершилась успешно. Ориентируйтесь на шесть действий.

2.1.* Какие действия должны произойти, если пополнение счёта телефона происходило бы через автоплатёж?

Приведите ответ в свободной форме.

`Ответ:`

## 2.1. Пользователь пополняет баланс счёта телефона

Предположим, человек пополняет телефон с банковской карты через сайт/приложение. Описываю **6 основных шагов**.

### 1. Формирование запроса на платеж
- Пользователь вводит номер телефона и сумму.
- Приложение отправляет запрос в платежный/биллинговый сервис:  
  `номер телефона + сумма + источник оплаты (карта/счёт)`.
- На этом этапе никаких изменений в БД ещё нет, только подготовка.

### 2. Начало транзакции в билинговой системе
- В БД оператора/платёжного сервиса выполняется `BEGIN TRANSACTION`.
- Создаётся запись о платеже со статусом, например, `PENDING`:
  - `payment_id`,
  - `phone_number`,
  - `amount`,
  - `status = 'PENDING'`,
  - время, идентификаторы пользователя и т.п.
- Это делается в одной транзакции, чтобы всё было консистентно.

### 3. Проверка и блокировка средств на источнике оплаты
- Система обращается к банку/платёжному шлюзу:
  - проверка, что карта/счёт действительны;
  - проверка, что хватает денег;
  - при необходимости — **блокировка суммы** (hold).
- Если что-то не так (нет денег, карта заблокирована и т.д.),  
  транзакция **откатывается (ROLLBACK)** и платёж получает статус `FAILED`.

### 4. Обновление баланса телефона и истории операций
Если банк ответил «ОК» и деньги успешно списаны/заблокированы:

В рамках всё той же транзакции в БД оператора:

1. Увеличивается баланс лицевого счёта телефона, например:
   - таблица `accounts`: поле `balance = balance + amount`.
2. В таблицу истории операций (`transactions` или `operations`)  
   добавляется запись:
   - `type = 'TOP_UP'`,
   - `amount`,
   - `old_balance`,
   - `new_balance`,
   - ссылка на `payment_id`.

### 5. Фиксация транзакции
- Если все действия прошли без ошибок:
  - выполняется `COMMIT`;
  - запись о платеже переводится в статус `SUCCESS`.
- Если на любом этапе внутри транзакции произошла ошибка:
  - делается `ROLLBACK`;
  - баланс телефона не меняется,
  - платёж помечается как `FAILED`.

Важно: либо деньги списались и баланс изменился, либо не произошло ничего — это как раз и есть суть транзакции.

### 6. Уведомление пользователя и внешних систем
После успешного `COMMIT`:

- Отправляется SMS или push пользователю:
  - «Ваш баланс пополнен на ХХХ рублей».
- Если требуется, формируется чек (для 54-ФЗ) и отправляется в ОФД.
- Статус платежа возвращается в интерфейс приложения/сайта.

---

## 2.1.* Пополнение через автоплатёж

С автоплатежом логика почти такая же, просто добавляется «автоматический запуск» и проверки лимитов. Опишу тоже в 6 шагах.

### 1. Настройка автоплатежа
Однажды пользователь настраивает автоплатёж:
- в БД создаётся запись, например в таблице `autopay_settings`:
  - `phone_number`,
  - `card_id` или платёжный метод,
  - условие срабатывания (например, «если баланс < 100 руб»),
  - сумма пополнения,
  - лимиты (максимум в день/месяц),
  - статус автоплатежа (`ACTIVE`).

Это делается заранее и вне основной платёжной транзакции.

### 2. Периодическая проверка условий автоплатежа
- Фоновый сервис (cron/daemon) периодически:
  - считывает настройки из `autopay_settings` с `status = 'ACTIVE'`;
  - проверяет текущий баланс по каждому номеру телефона;
  - сравнивает с порогом (например, баланс < 100 руб).

Если условие выполняется, формируется запрос на платёж (как если бы пользователь нажал «Пополнить» вручную).

### 3. Проверка лимитов и состояния платёжного средства
Перед тем, как реально списывать:

- Проверяются лимиты автоплатежа:
  - не превышен дневной/месячный лимит;
  - автоплатёж не заблокирован (например, из-за ошибок).
- Проверяется актуальность карты/счёта:
  - не истёк срок действия,
  - не отозван автоплатёж самим пользователем.

Если проверки не пройдены — платёж не запускается, можно создать запись об ошибке и уведомить пользователя.

### 4. Запуск транзакции автоплатежа
Дальше всё почти как в п. 2.1:

1. `BEGIN TRANSACTION` в билинговой системе.
2. Создаётся запись о платеже с типом `AUTOPAY`, статус `PENDING`.
3. Идёт запрос к платёжному шлюзу/банку на списание средств.

### 5. Обновление баланса телефона и фиксация
Если банк ответил «успешно»:

- Баланс телефона увеличивается на указанную сумму.
- Записывается операция в историю (`TOP_UP`, источник — автоплатёж).
- Транзакция фиксируется `COMMIT`.
- Статус платежа меняется на `SUCCESS`.

Если что-то пошло не так — `ROLLBACK`, платёж помечается как `FAILED`.

### 6. Уведомление пользователя и возможные реакции системы
После завершения автоплатежа:

- Пользователю отправляется уведомление:
  - «Автоплатёж сработал, баланс пополнен на ХХХ руб»  
  или  
  - «Автоплатёж не сработал: не удалось списать средства».
- При нескольких подряд неуспешных автоплатежах система может:
  - временно отключить автоплатёж,
  - попросить пользователя обновить данные карты.

---

Таким образом, автоплатёж — это те же транзакции, что и при обычном пополнении, но запуск инициируется не пользователем вручную, а фоновым сервисом по заданным условиям, с дополнительными проверками лимитов и статуса автоплатежа.

---

Задание 3. SQL vs NoSQL
3.1. Напишите пять преимуществ SQL-систем по отношению к NoSQL.

3.1.* Какие, на ваш взгляд, преимущества у NewSQL систем перед SQL и NoSQL.

Приведите ответ в свободной форме.

`Ответ:`

## 3.1. Пять преимуществ SQL-систем перед NoSQL

### **1. Строгая структура данных (схемы и типы)**
SQL-базы используют схемы и типизацию. Это помогает:
- держать данные в порядке,
- избегать ошибок,
- гарантировать, что данные соответствуют бизнес-правилам.

NoSQL часто позволяет хранить «что угодно», что удобно, но иногда приводит к хаосу.

---

### **2. ACID-транзакции как стандарт**
Реляционные СУБД обеспечивают:
- атомарность,
- согласованность,
- изолированность,
- долговечность.

То есть операции либо выполняются полностью, либо не выполняются вообще.  
В NoSQL транзакции либо ограничены, либо вообще отсутствуют (зависит от реализации).

---

### **3. Мощный язык SQL и сложные запросы**
SQL — богатый язык: JOIN, GROUP BY, подзапросы, окна, аналитические функции.  
На NoSQL сложные фильтры, связи и выборки часто реализуются неудобно или требуют ручной логики на стороне приложения.

---

### **4. Хорошо подходит для связанных данных**
Реляционная модель создана для работы с отношениями:
- клиенты — заказы,
- сотрудники — должности,
- товары — категории.

В NoSQL связи обычного типа JOIN отсутствуют или сильно ограничены, и приходится дублировать данные.

---

### **5. Зрелая технология и огромная экосистема**
SQL существует десятки лет. Для него есть:
- инструменты мониторинга,
- репликации,
- бэкапа,
- оптимизаторы запросов,
- поддержка кластеров,
- развитые инструменты безопасности.

NoSQL-системы моложе и часто не дают такого уровня зрелости и стабильности.

---

## 3.1.* Преимущества NewSQL перед SQL и NoSQL

NewSQL — это попытка совместить лучшее от обеих технологий.  
Выглядит как SQL, но масштабируется, как NoSQL.

### **1. Горизонтальное масштабирование (как NoSQL)**
В обычных SQL-системах горизонтальный масштаб — это боль (кроме дорогих корпоративных решений).  
NewSQL умеет:
- легко добавлять новые узлы,
- распределять нагрузку,
- автоматически шардировать данные.

Это особенно круто для высоконагруженных систем.

---

### **2. Полные ACID-транзакции (как SQL)**
В отличие от NoSQL, NewSQL даёт полноценные транзакции и строгую консистентность — без истории типа «данные могут появиться с задержкой».

---

### **3. Использование SQL как языка запросов**
В NewSQL остаётся знакомый SQL:
- JOIN’ы,
- индексы,
- триггеры,
- оптимизаторы.

Разработчикам не нужно учить новые языки или переписывать архитектуру — вход низкий.

---

### **4. Высокая производительность на больших нагрузках**
Современные NewSQL-системы проектируются под:
- огромные объёмы данных,
- высокую скорость записи/чтения,
- распределённые транзакции.

Например: CockroachDB, TiDB, YugabyteDB.

---

### **5. Автоматическое управление репликацией и отказоустойчивостью**
NewSQL обычно включает:
- автоматическое хранение данных в нескольких узлах,
- самоисцеление (node recovery),
- распределённые транзакции,
- балансировку нагрузки.

SQL-системы это умеют, но обычно через внешние механизмы.  
NewSQL делает это «из коробки».

---

### ***Итог:***  
**SQL — порядок и строгая логика.**  
**NoSQL — гибкость и масштабируемость.**  
**NewSQL — попытка выбрать лучшее из обоих миров: ACID + горизонтальный масштаб + SQL-язык.**

---

Задание 4. Кластеры
Необходимо производить большое количество вычислений при работе с огромным количеством данных, под эту задачу выделено 1000 машин.

На основе какого критерия будете выбирать тип СУБД и какая модель распределённых вычислений здесь справится лучше всего и почему?

Приведите ответ в свободной форме.

`Ответ:`

## Как выбрать тип СУБД?

Когда речь идёт о **большом количестве вычислений** и **огромных объёмах данных**, да ещё и выделено **1000 машин**, главный критерий выбора СУБД — это:

### **Способность эффективно масштабироваться горизонтально**  
(то есть уметь распределять данные и вычисления по многим узлам, а не упираться в один сервер).

Обычные реляционные БД (PostgreSQL, MySQL) в такой ситуации не подходят — у них горизонтальное масштабирование ограничено и обычно требуется много «костылей».

Поэтому основным критерием является:

> **Тип нагрузки + режим консистентности + модель вычислений, которая лучше всего распараллеливается при большом количестве узлов.**

Если задача — анализ огромных данных, агрегирование, обработка логов, машинное обучение, то нужно выбирать:

- **Колоночные распределённые СУБД**:  
  - ClickHouse  
  - Vertica  
  - Greenplum  

или

- **NoSQL с сильной горизонтальной масштабируемостью**:  
  - Apache Cassandra  
  - HBase (на Hadoop)  
  - Bigtable-подобные решения  

Эти системы специально созданы для кластеров из сотен/тысяч узлов.

---

## Какая модель распределённых вычислений подходит лучше всего?

В большие кластеры (1000 машин) отлично ложится модель **MapReduce** и её производные.

### Почему MapReduce?

Потому что она:
- идеально работает на огромных наборах данных;
- простая: раздаёт куски данных по узлам → выполняет вычисления → собирает результат;
- не требует сложных транзакций;
- масштабируется почти линейно с количеством узлов;
- выдерживает падения отдельных машин;
- используется большинством крупных BigData-систем.

### Что используется на практике?

Обычно применяют один из следующих вариантов:

### **1. Hadoop + HDFS + MapReduce**  
Классика Big Data.  
Подходит для:
- обработки больших логов,
- аналитики,
- сложных расчётов,
- batch-вычислений.

### **2. Apache Spark**  
Современная замена MapReduce.  
Преимущества:
- быстрее за счёт работы в памяти,
- поддерживает SQL, стриминг, ML,
- может использовать кластер из сотен машин.

### **3. Колоночные MPP-СУБД (Massively Parallel Processing)**  
Например:  
- ClickHouse  
- Greenplum  
- Snowflake (облачно)  

Они сами реализуют распределённые вычисления:
- данные разбиваются на шары (shards),
- запросы выполняются параллельно на всех узлах кластера,
- результат собирается координатором.

---

## Итоговое решение

**Тип СУБД:**  
- распределённая колоночная СУБД или NoSQL, которая умеет горизонтально масштабироваться на сотни узлов (ClickHouse, Cassandra, Greenplum, HBase).  

**Критерий выбора:**  
- способность выполнять параллельные вычисления при огромных объёмах данных  
- и эффективно использовать 1000 машин.

**Лучшая модель вычислений:**  
- **MapReduce или Spark**,  
потому что они:
- легко распараллеливают работу,
- эффективно используют ресурсы большого кластера,
- устойчивы к сбоям,
- предназначены для Big Data.

---

То есть оптимальный вариант — это система, построенная вокруг Spark или MPP-СУБД, которая может распределить данные по 1000 узлам и выполнять вычисления параллельно и надёжно.



